[{"content":"Writing Golang Fluent Bit Input Plugins Introduction Welcome to this guide on writing Golang input plugins for Fluent Bit! In this document, we will walk you through the process of creating an extensible plugin interface for Fluent Bit input using Golang. This will allow you to easily extend Fluent Bit\u0026rsquo;s capabilities and integrate custom functionality into your data processing pipeline.\nContext Fluent Bit is a highly reliable and memory-efficient pipeline data processing engine. It is widely used as a low-forwarder in the Cloud-native landscape and supports metrics and traces as core features. While Fluent Bit itself is written in C, it provides extensible interfaces that allow input, filter, and output plugins to be written in various languages, including Golang.\nAt Calyptia, we have developed a Golang library to support writing input plugins for Fluent Bit. You can find the library at https://github.com/calyptia/plugin.\nHow to Write a Golang Input Plugin To demonstrate how easy it is to extend Fluent Bit\u0026rsquo;s input capabilities, let\u0026rsquo;s consider a scenario where we want to monitor the status of GitHub and send an alert to a Slack channel in case of an outage. We will break down the implementation into the following steps:\nFetch the GitHub status API. Filter the response to check if the status is operational. We will implement this using a Fluent Bit Lua filter. Dispatch a message to Slack. We will utilize the Fluent Bit Slack output plugin for this part. For Step 1, we will implement a custom Fluent Bit input plugin using Golang.\nImplementing the Plugin Implementing an input plugin in Golang requires implementing a simple interface defined in the github.com/calyptia/plugin package:\n1 2 3 4 type InputPlugin interface { Init(ctx context.Context, fbit *Fluentbit) error Collect(ctx context.Context, ch chan\u0026lt;- Message) error } You can find further information on implementing this interface in the github.com/calyptia/plugin repository.\nHere\u0026rsquo;s an example implementation of a Fluent Bit input plugin for monitoring GitHub status:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package main import ( \u0026#34;context\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/calyptia/plugin\u0026#34; ) const ( GithubStatusEndpointJSON = \u0026#34;https://www.githubstatus.com/api/v2/status.json\u0026#34; ScrapeInterval = time.Minute * 5 ) type GithubStatusResponse struct { Page struct { ID string `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` URL string `json:\u0026#34;url\u0026#34;` TimeZone string `json:\u0026#34;time_zone\u0026#34;` UpdatedAt time.Time `json:\u0026#34;updated_at\u0026#34;` } `json:\u0026#34;page\u0026#34;` Status struct { Indicator string `json:\u0026#34;indicator\u0026#34;` Description string `json:\u0026#34;description\u0026#34;` } `json:\u0026#34;status\u0026#34;` } func init() { plugin.RegisterInput(\u0026#34;go-fluentbit-github-status\u0026#34;, \u0026#34;Golang input plugin for checking the status of GitHub\u0026#34;, \u0026amp;GithubStatusPlugin{}) } type GithubStatusPlugin struct{} func (plug *GithubStatusPlugin) Init(ctx context.Context, fbit *plugin.Fluentbit) error { return nil } func (plug *GithubStatusPlugin) Collect(ctx context.Context, ch chan\u0026lt;- plugin.Message) error { tick := time.NewTicker(ScrapeInterval) for { select { case \u0026lt;-ctx.Done(): err := ctx.Err() if err != nil \u0026amp;\u0026amp; !errors.Is(err, context.Canceled) { return err } return nil case \u0026lt;-tick.C: resp, err := http.Get(GithubStatusEndpointJSON) if err != nil { log.Fatal(err) } responseData, err := io.ReadAll(resp.Body) if err != nil { log.Fatal(err) } var githubStatusResponse GithubStatusResponse err = json.Unmarshal(responseData, \u0026amp;githubStatusResponse) if err != nil { log.Fatal(err) } ch \u0026lt;- plugin.Message{ Time: time.Now(), Record: map[string]interface{}{ \u0026#34;data\u0026#34;: githubStatusResponse, }, } } } } func main() {} In this example, we implement the Collect method, which periodically fetches the GitHub status information and sends it as a message. We use the time and net/http packages to make the API request and process the response using JSON encoding.\nBuilding the Plugin To build the plugin, use the following command:\n1 go build -trimpath -buildmode c-shared -o github_status.so . If you are using an M1-based machine, compile the plugin with the following command:\n1 2 3 4 5 6 CGO_ENABLED=1 \\ GOOS=linux \\ GOARCH=amd64 \\ CC=\u0026#34;zig cc -target x86_64-linux-gnu -isystem /usr/include -L/usr/lib/x86_64-linux-gnu\u0026#34; \\ CXX=\u0026#34;zig c++ -target x86_64-linux-gnu -isystem /usr/include -L/usr/lib/x86_64-linux-gnu\u0026#34; \\ go build -trimpath -buildmode c-shared -o github_status.so . The resulting github_status.so file should be placed in the /fluent-bit/etc directory.\nConfiguration To complete Steps 2 and 3, you need a Fluent Bit configuration that includes filtering the input records and sending them to Slack. Here\u0026rsquo;s an example Fluent Bit configuration (fluent-bit.yaml) that uses the Go Fluent Bit GitHub Status plugin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 service: flush: 1 log_level: debug plugins_file: /fluent-bit/etc/plugins.conf Parsers_file: /fluent-bit/etc/parsers.conf pipeline: inputs: - Name: go-fluentbit-github-status filters: - Name: lua Match: \u0026#39;*\u0026#39; call: filter code: | function filter(tag, timestamp, record) if record.status and record.status.status and record.status.status.description == \u0026#34;All Systems Operational\u0026#34; then record = { status = \u0026#34;✅ All GitHub systems are operational\u0026#34; } else record = { status = \u0026#34;❌ Issues with GitHub (check: https://www.githubstatus.com/)\u0026#34; } end return 2, timestamp, record end outputs: - Name: slack Match: \u0026#39;*\u0026#39; webhook: https://hooks.slack.com/xxxx Replace https://hooks.slack.com/xxxx with the actual webhook URL for your Slack integration.\nAdditionally, create a plugins.conf file with the following content:\n1 2 [PLUGINS] Path /fluent-bit/etc/go-fluentbit-github-status.so Running the Plugin Finally, run the latest Fluent Bit release with the plugin loaded and executed using the following command:\n1 docker run -v $(pwd)/github_status.so:/fluent-bit/etc/go-fluentbit-github-status.so -v $(pwd)/fluent-bit.yaml:/fluent-bit/etc/fluent-bit.yaml:ro -v $(pwd)/plugins.conf:/fluent-bit/etc/plugins.conf:ro fluent/fluent-bit:2.1.2 -c /fluent-bit/etc/fluent-bit.yaml Adjust the volume mounts ($(pwd) represents the current directory) and the Fluent Bit image tag according to your environment.\nWith this configuration, the Go Fluent Bit GitHub Status plugin will periodically check the GitHub status and rewrite the record\u0026rsquo;s \u0026ldquo;status\u0026rdquo; field to indicate whether all systems are operational or if there are issues. The output can be sent to a Slack channel using the slack output plugin or modified to fit your specific use case.\nConclusion Congratulations! You have successfully written a Golang input plugin for Fluent Bit. This demonstrates how easy it is to extend Fluent Bit\u0026rsquo;s functionality using Golang and integrate custom features into your data processing pipeline. Feel free to explore other possibilities and experiment with different plugins and configurations to suit your specific requirements. The plugin works flawless, it runs every 5 minutes and reports back the status to the slack channel.\nLinks The source code of this experiment can be found here: https://github.com/niedbalski/go-fluentbit-github-status.\n","permalink":"http://niedbalski.dev/posts/writing-golang-fluent-bit-input-plugins/","summary":"Writing Golang Fluent Bit Input Plugins Introduction Welcome to this guide on writing Golang input plugins for Fluent Bit! In this document, we will walk you through the process of creating an extensible plugin interface for Fluent Bit input using Golang. This will allow you to easily extend Fluent Bit\u0026rsquo;s capabilities and integrate custom functionality into your data processing pipeline.\nContext Fluent Bit is a highly reliable and memory-efficient pipeline data processing engine.","title":"Writing Golang Fluent Bit Input Plugins"}]